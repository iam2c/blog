# 0x01 为啥写这篇文章
一年半之前来到公司，就听公司他们讨论说HTTPS的请求会被截获拿到明文，那时候忙没注意也跟他们深究。最近又听到这个说法，由于最近不怎么忙，所以和他们讨论了一下，说了我的理解，为啥他们的理解是错的。这里先说说他们的说法：

    手机使用fiddler等代理，代理捕获并转发HTTPS请求，代理充当中间人的角色，能够得到HTTP请求和响应的具体内容（明文）。
        
我的观点是：

    除非客户端信任代理的证书，否则无法得到HTTP请求和响应的具体内容（明文）。


为什么这么说呢？下面我们用通俗点的语言来说说。

先说明一下，前提是RSA作为密钥交换的算法，也就是协商后面用到的对称加密密钥的过程用到的算法。而且普遍应用都是用RSA作为密钥交换的算法。

# 0x02 HTTPS代理的交互

```
说明：
    1.下面所说的数据都是指TCP层以上（不包括TCP的）的数据。
    2.由于HTTPS是HTTP基于SSL层，而SSL又是基于TCP，所以数据就是SSL层及其以上层（包括）的数据
    3.代理（中间人）不知道证书C1中公钥PUK1对应的私钥PRK1
    4.客户端只安装权威机构的CA证书
```

#### （1）先上图

![https代理交互](https://github.com/iam2c/blog/blob/master/assets/https_proxy/https-1.png?raw=true)

<center>图1</center>


```
注意：
    1. {密钥|对称加密算法}表示前面的内容用什么密钥和算法进行加密
```


#### （2）图解

1. 因为客户端（如手机）通过代理（如fiddler）转发的，所以客户端和代理之间一般都是通过HTTP/1.1通信的。这跟VPN和SOCK5不一样。
2. 代理拿到1的报文，解出来知道要连接哪个域名的服务器，连接上。
3. 代理告诉客户端连上了。
4. 客户端发送自己支持的算法，比如对称加密算法有什么什么，密钥交换算法有什么什么，摘要算法有什么什么，供服务器选择。还有客户端的随机数R1，后面生成对称加密的密钥用到。
5. 代理转发内容，到这里还是明文的。代理是可以看到客户端请求的域名的。
6. 服务器根据客户端和自身情况选择了一组加密算法，不一定是图上的组合，以及服务端的随机数R2一起告诉代理（这里的代理在服务器来看其实就是一个客户端）。这里的随机数跟客户端的随机数一样后面生成对称加密的密钥用到。还会发给代理，服务器对应这个域名的证书。
7. 代理把步骤6服务器返回的原样返回给客户端。
8. 客户端验证证书的正确性，验证的步骤后面会详细讲。证书里面有公钥、主体信息（在本例中包括域名），当然还有其他信息后面会讲到。
9. 以上步骤交互都是明文的。在步骤9验证了证书的正确性后，拿到公钥，发送另一个随机数R3，用公钥加密，把密文发给代理。代理是没法解出来，因为代理没有该公钥对应的私钥，服务器才有。到这里客户端和服务器生成了3个随机数。
10. 代理把TCP层以上的数据转发给服务器，同样代理没法知道里面具体什么内容。
11. 根据这3个随机数和上面约定好的加密算法按照一个一定的算法生成会话后面用的对称加密算法的密钥。当然服务端按照一定的算法也能生成同样密钥。
12. 同11
13. 服务器告诉代理协商好了，内容用的是服务器该域名的私钥加密的，代理是可以解出来的，但是代理不知道R3没法算出密钥。
14. 代理转发TCP层以上的数据转发给客户端。
15. 客户端收到步骤14的内容（把TCP层以上的数据转发给客户端，相当于客户端跟服务端直接交互差不多，只是TCP/IP层做一下修改而已）。使用步骤12生成的密钥加密HTTP请求内容，发给代理，代理也是无法解出来HTTP请求内容。后面的步骤都是使用对称加密对请求和响应加密，客户端有密钥可以解出明文，代理无法解出来。
16. 代理转发TCP层以上的数据转发给服务器。
17. 服务端返回HTTP响应内容。
18. 拿到服务端响应的密文，使用密钥解密，得到原来HTTP响应内容。

下面附上一个我抓包的图：

![https抓包](https://github.com/iam2c/blog/blob/master/assets/https_proxy/https-2.png?raw=true)

<center>图2</center>

```
注意：
    1. 172.16.10.216是代理服务器，172.16.30.157是客户端，172.16.30.106是服务端
    2. 图上红色的数字跟上面图解的序号对应
```

#### （3）分析
通过上面的图和图解，我们可以看出：重要的是步骤9的R3，代理没法解出来，所以没法知道对称加密的密钥是什么。

但是也有人提出问题来了：

**问题1**：如果代理（中间人）在客户端之间充当服务器角色，在和服务器之间充当客户端角色，也就是两边伪造身份。那么和客户端通信中伪造（篡改）随机数R2和证书C1，伪造为R2'和C1'，而和服务端通信中随机数R1和随机数R3也可以伪造，伪造为R1'和R3'，知道了随机数就可以算出对称加密的密钥了，自然就可以解除后面的HTTP请求和响应的内容。

**解答1**：确实代理是可以篡改任何数据。在和服务端通信中，完全充当客户端的角色，这个肯定是没有问题的。但是在和客户端通信中，客户端会验证证书是否是可信的，如果证书不可信会提示错误。至于如何验证后面再说。

下面这张图就是代理在客户端和服务端篡改通信信息的包图：

![https伪造服务端](https://github.com/iam2c/blog/blob/master/assets/https_proxy/https-err-ca.png?raw=true)

<center>图3</center>

```
注意：
    1. 172.16.10.216是代理服务器，172.16.30.157是客户端，172.16.30.106是服务端
```

从上图可以看出：伪造证书后，客户端验证证书不可信，就提示错误信息Unknown CA。对比图1和图3，可以发现：对于客户端发送的数据，代理伪造信息过程（图3）中，并不像正常通信（图1）中原样转发数据，而是自己充当客户端跟服务器通信（图3中序号4-6）。而返回给客户端证书时发送自己伪造的证书（图3步骤7）：

![https伪造服务端](https://github.com/iam2c/blog/blob/master/assets/https_proxy/https-err-ca-1.png?raw=true)

<center>图4</center>

从图4中可以看到，代理（示例中用的fiddler）发送了自己的证书，证书的颁发者改成自己的（虽然没有截取正确的证书信息，但是你看看就知道了，这是fiddler自己的根证书，图4中序号1），而使用者还是原来的www.grpc.local（图4中序号2）。但是客户端没有信任fiddler的根证书，所以图3步骤8就提示错误了。

# 0x03 总结
上面过程中，客户端验证证书很重要，如果客户端不信任服务端发过来的证书（比如中间人篡改了），那么客户端就会报错（证书错误）。所以上面的问题自然而然就可以得出结论了，但是代理还是知道一些信息的，比如域名。但是如果说客户端信任了服务端发过来的证书（比如导入了相应的根证书，如上面示例Fiddler自己的根证书，或者是客户端忽略证书错误信息，直接信任该证书），这样才能够继续后面的步骤，代理才知道后面的HTTP请求和响应的具体内容（明文）。

这个过程中这些提供了保证：
1. RSA保证了中间人没有私钥无法破解公钥加密的密文。
2. CA根证书及证书验证保证了证书的正确性，无法被中间人篡改。
3. 其实CA验证过程中还有哈希算法（sha256等），生成数字签名，保证证书内容无法被篡改，后面会说到。
4. 对称加密算法（DES、AES）也是比较难破解的，特别是密钥比较长的时候。

# 0x04 附录一：证书的验证
未完待续。。。